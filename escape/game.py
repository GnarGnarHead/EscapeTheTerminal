"""Escape the Terminal - minimal command loop.

This module now exposes a :class:`Game` object to make future expansion
easier while preserving the original command-line interface.
"""

from __future__ import annotations

from pathlib import Path
import os
import json


class Game:
    """Simple command dispatcher for the terminal adventure."""

    def __init__(
        self,
        use_color: bool | None = None,
        world_file: str | Path | None = None,
        prompt: str | None = None,
    ):
        if use_color is None:
            env_val = os.getenv("ET_COLOR", "0").lower()
            self.use_color = env_val not in ("0", "false", "")
        else:
            self.use_color = use_color

        env_dir = os.getenv("ET_COLOR_DIR")
        self.dir_color = f"\x1b[{env_dir}m" if env_dir else "\x1b[33m"
        env_item = os.getenv("ET_COLOR_ITEM")
        self.item_color = f"\x1b[{env_item}m" if env_item else "\x1b[36m"

        self.auto_save = os.getenv("ET_AUTOSAVE") not in (None, "", "0", "false")
        self.prompt = prompt if prompt is not None else os.getenv("ET_PROMPT", "> ")
        self.inventory = []
        self.visited_dirs: set[str] = {'/'}
        self.collected_items: set[str] = set()
        self.score = 0
        self.achievements: list[str] = []
        self.data_dir = Path(__file__).parent / "data"
        if world_file is None:
            world_file = self.data_dir / "world.json"
        with open(world_file, "r", encoding="utf-8") as f:
            world = json.load(f)
        self.fs = world.get("fs", {})
        self._base_root_desc = self.fs.get("desc", "")
        self.hidden_dir = world.get("hidden_dir", {})
        self.network_node = world.get("network_node", {})
        self.deep_network_node = world.get("deep_network_node", {})
        self.npc_locations = world.get("npc_locations", {})
        self.item_descriptions = world.get("item_descriptions", {})
        self.recipes = world.get("recipes", {})
        self.current = []  # path as list of directory names
        # track dialogue progress and flags for each NPC
        self.npc_state: dict[str, dict] = {}
        # flags that apply to all NPCs based on achievements
        self.npc_global_flags: dict[str, bool] = {}
        # populate multiple directories with extra procedurally generated content
        self._generate_extra_dirs(["dream", "memory", "core"])
        self.use_messages = {
            "access.key": "The key hums softly and a hidden directory flickers into view.",
            "mem.fragment": "Fragments of your past flash before your eyes.",
            "voice.log": "A haunting voice whispers: 'Find the fragment.'",
            "daemon.log": "The daemon rasps from deep within the system: 'Keep your code clean.'",
            "lucid.note": "The words resonate, sharpening your awareness of the dream.",
            "flashback.log": "Memories surge forth, revealing forgotten paths.",
        }
        self.save_file = "game.sav"
        env_save_dir = os.getenv("ET_SAVE_DIR")
        self.save_dir = Path(env_save_dir) if env_save_dir else Path.cwd()
        self.glitch_mode = False
        self.glitch_steps = 0

        # store all commands the player enters this session
        self.command_history: list[str] = []

        # notes recorded by the player
        self.journal: list[str] = []

        # active quests tracked by the player
        self.quests: list[str] = []
        # begin with an initial quest
        self.quests.append("Recover your lost memory")

        # runtime command aliases created via the 'alias' command
        self.aliases: dict[str, str] = {}

        # names of plugin modules successfully loaded
        self.loaded_plugins: list[str] = []

        # directory for autogenerated log files
        self.logs_path = self.data_dir / "logs"
        self._generate_logs()

        # descriptions for help output
        self.command_descriptions = {
            "help": "Show help for commands",
            "man": "Show a manual page for a command",
            "look": "Describe the current room or a subdirectory",
            "ls": "List items and subdirectories",
            "cd": "Change directory",
            "pwd": "Show current path",
            "take": "Add an item to your inventory",
            "drop": "Remove an item from your inventory",
            "inventory": "List inventory contents",
            "examine": "Examine an item in detail",
            "use": "Use an item, optionally on a target",
            "combine": "Combine two items if a recipe matches",
            "cat": "Display the contents of a file",
            "grep": "Search log files for text",
            "decode": "Decode the mem.fragment",
            "talk": "Speak with an NPC",
            "scan": "Scan a directory for hidden nodes",
            "hack": "Attempt to unlock a node",
            "map": "Display the directory tree",
            "save": "Save game state",
            "load": "Load a saved game",
            "glitch": "Toggle glitch mode",
            "color": "Toggle ANSI color output",
            "prompt": "Change or display the input prompt",
            "history": "Show command history",
            "journal": "View or add personal notes",
            "quest": "List, add or complete quests",
            "sleep": "Enter the dream state and rest",
            "score": "Show your current score",
            "stats": "Show gameplay statistics",
            "achievements": "List unlocked achievements",
            "tutorial": "Guided introduction to core commands",
            "restart": "Restart the game",
            "quit": "Exit the game",
            "alias": "Create command shortcuts",
            "unalias": "Remove a command alias",
            "plugins": "List loaded plugins",
        }

        # map commands and aliases to handler callables
        self.command_map = {
            "help": lambda arg="": self._print_help(arg.strip()),
            "h": lambda arg="": self._print_help(arg.strip()),
            "man": lambda arg="": self._man(arg),
            "look": lambda arg="": self._look(arg),
            "look around": lambda arg="": self._look(),
            "ls": lambda arg="": self._ls(),
            "pwd": lambda arg="": self._pwd(),
            "cd": lambda arg="": self._cd(arg),
            "take": lambda arg="": self._take(arg),
            "drop": lambda arg="": self._drop(arg),
            "inventory": lambda arg="": self._inventory(),
            "inv": lambda arg="": self._inventory(),
            "i": lambda arg="": self._inventory(),
            "examine": lambda arg="": self._examine(arg),
            "use": lambda arg="": self._use_command(arg),
            "combine": lambda arg="": self._combine(arg),
            "cat": lambda arg="": self._cat(arg),
            "grep": lambda arg="": self._grep(arg),
            "decode": lambda arg="": self._decode(arg),
            "talk": lambda arg="": self._talk(arg),
            "scan": lambda arg="": self._scan(arg),
            "hack": lambda arg="": self._hack(arg),
            "map": lambda arg="": self._map(),
            "save": lambda arg="": self._save(arg),
            "load": lambda arg="": self._load(arg),
            "glitch": lambda arg="": self._toggle_glitch(),
            "color": lambda arg="": self._color(arg),
            "prompt": lambda arg="": self._prompt(arg),
            "history": lambda arg="": self._history(),
            "journal": lambda arg="": self._journal(arg),
            "quest": lambda arg="": self._quest(arg),
            "sleep": lambda arg="": self._sleep(arg),
            "score": lambda arg="": self._score(),
            "stats": lambda arg="": self._stats(),
            "achievements": lambda arg="": self._achievements(),
            "tutorial": lambda arg="": self._tutorial(),
            "restart": lambda arg="": self._restart(),
            "quit": lambda arg="": self._quit(),
            "exit": lambda arg="": self._quit(),
            "alias": lambda arg="": self._alias(arg),
            "unalias": lambda arg="": self._unalias(arg),
            "plugins": lambda arg="": self._plugins(),
        }

        # discover and load optional plugin modules
        self._load_plugins()

    def _generate_extra_dirs(self, bases: list[str] | str = "dream") -> None:
        """Populate directories under each base path with random subdirectories."""
        import os
        import random

        if isinstance(bases, str):
            bases = [bases]

        seed_val = os.getenv("ET_EXTRA_SEED")
        rnd = random.Random(int(seed_val)) if seed_val is not None else random.Random()
        count_val = os.getenv("ET_EXTRA_COUNT")
        try:
            fixed_count = int(count_val) if count_val is not None else None
        except ValueError:
            fixed_count = None

        adjectives = ["misty", "vivid", "neon", "echoing"]
        nouns = ["hall", "nexus", "alcove", "node"]
        item_defs = [
            ("dream.shard", "A sliver of surreal memory."),
            ("echo.bit", "An echo of a forgotten idea."),
            ("vision.chip", "A chip flickering with ephemeral scenes."),
        ]
        for base in bases:
            base_node = self.fs["dirs"].get(base)
            if not base_node:
                continue

            count = fixed_count if fixed_count is not None else rnd.randint(2, 3)
            for idx in range(count):
                dname = f"{rnd.choice(adjectives)}_{rnd.choice(nouns)}_{idx}"
                desc = f"A {rnd.choice(['strange', 'fleeting', 'curious'])} place within the dream."
                items: list[str] = []
                if rnd.random() < 0.5:
                    it_name, it_desc = rnd.choice(item_defs)
                    it_name = it_name.replace(".", f"{idx}.")
                    items.append(it_name)
                    self.item_descriptions[it_name] = it_desc
                base_node["dirs"][dname] = {"desc": desc, "items": items, "dirs": {}}

    def _generate_logs(self) -> None:
        """Create the logs directory with random log files."""
        import os
        import random

        self.logs_path.mkdir(exist_ok=True)
        for old in self.logs_path.glob("*.log"):
            try:
                old.unlink()
            except OSError:
                pass
        seed_val = os.getenv("ET_EXTRA_SEED")
        rnd = random.Random(int(seed_val)) if seed_val is not None else random.Random()

        count = rnd.randint(3, 5)
        files: list[str] = []
        for i in range(count):
            fname = f"system_{rnd.randint(1000,9999)}.log"
            files.append(fname)
            lines = [
                f"INFO iteration {i}",
                (
                    "SYSTEM BOOT COMPLETE"
                    if i == 0
                    else f"DEBUG value {rnd.randint(0,100)}"
                ),
            ]
            with open(self.logs_path / fname, "w", encoding="utf-8") as f:
                f.write("\n".join(lines) + "\n")

        self.fs["dirs"]["logs"] = {
            "desc": "System logs are stored here.",
            "items": files,
            "dirs": {},
        }
        for name in files:
            self.item_descriptions.setdefault(name, "A cryptic system log file.")

    def _load_plugins(self) -> None:
        """Import plugin modules from built-in and custom plugin directories."""
        import importlib.util
        import sys
        import zipimport

        builtin_dir = Path(__file__).parent / "plugins"
        plugin_dirs = []
        if builtin_dir.is_dir():
            plugin_dirs.append(builtin_dir)

        extra_paths = os.getenv("ET_PLUGIN_PATH")
        if extra_paths:
            for p in extra_paths.split(os.pathsep):
                if not p:
                    continue
                path = Path(p)
                if path.is_dir():
                    plugin_dirs.append(path)

        for plugins_dir in plugin_dirs:
            # load regular Python files
            for path in plugins_dir.glob("*.py"):
                if path.name.startswith("__"):
                    continue
                if plugins_dir == builtin_dir:
                    module_name = f"escape.plugins.{path.stem}"
                else:
                    module_name = path.stem
                spec = importlib.util.spec_from_file_location(module_name, path)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    module.game = self
                    sys.modules[module_name] = module
                    try:
                        spec.loader.exec_module(module)
                        self.loaded_plugins.append(module_name)
                    except Exception as exc:
                        print(f"Failed to load plugin {path.name}: {exc}")

            # load zipped plugins
            for path in plugins_dir.glob("*.zip"):
                if plugins_dir == builtin_dir:
                    module_name = f"escape.plugins.{path.stem}"
                else:
                    module_name = path.stem
                try:
                    importer = zipimport.zipimporter(str(path))
                except zipimport.ZipImportError as exc:
                    print(f"Failed to read plugin {path.name}: {exc}")
                    continue
                spec = importlib.util.spec_from_loader(module_name, importer)
                if spec and spec.loader:
                    try:
                        if hasattr(importer, "exec_module"):
                            module = importlib.util.module_from_spec(spec)
                            module.game = self
                            sys.modules[module_name] = module
                            importer.exec_module(module)
                            self.loaded_plugins.append(module_name)
                        else:
                            # zipimporter on older Python versions lacks exec_module
                            # so we manually execute the plugin code with the game
                            # instance available in globals
                            import zipfile

                            with zipfile.ZipFile(path) as zf:
                                target = f"{path.stem}.py"
                                if target in zf.namelist():
                                    source = zf.read(target).decode("utf-8")
                                else:
                                    raise FileNotFoundError(
                                        f"{target} not found in {path.name}"
                                    )

                            module = importlib.util.module_from_spec(spec)
                            module.game = self
                            sys.modules[module_name] = module
                            exec(compile(source, target, "exec"), module.__dict__)
                            self.loaded_plugins.append(module_name)
                    except Exception as exc:
                        print(f"Failed to load plugin {path.name}: {exc}")

    def _toggle_glitch(self):
        self.glitch_mode = not self.glitch_mode
        state = "activated" if self.glitch_mode else "deactivated"
        if not self.glitch_mode:
            self.glitch_steps = 0
        print(f"Glitch mode {state}.")

    def _color(self, arg: str = "") -> None:
        """Enable, disable, or toggle ANSI color output."""
        arg = arg.strip().lower()
        if not arg or arg == "toggle":
            self.use_color = not self.use_color
        elif arg == "on":
            self.use_color = True
        elif arg == "off":
            self.use_color = False
        else:
            self._output("Usage: color [on|off|toggle]")
            return
        state = "enabled" if self.use_color else "disabled"
        self._output(f"Color {state}.")

    def _prompt(self, arg: str = "") -> None:
        """Change or show the current input prompt."""
        text = arg
        if text.strip():
            self.prompt = text
            self._output(f"Prompt set to {self.prompt}")
        else:
            self._output(self.prompt)

    def _plugins(self) -> None:
        """Display the names of loaded plugin modules."""
        if self.loaded_plugins:
            for name in self.loaded_plugins:
                self._output(name)
        else:
            self._output("No plugins loaded.")

    def _output(self, text: str = "") -> None:
        """Print text, applying glitch effects when enabled."""
        if self.glitch_mode and text:
            self.glitch_steps += 1
            text = self._glitch_text(text, self.glitch_steps)
            import random

            rnd = random.Random(self.glitch_steps * 42)
            if self.glitch_steps in (3, 6, 9):
                msg = rnd.choice(
                    [
                        "-- SYSTEM CORRUPTION --",
                        "** SIGNAL LOST **",
                        "[memory anomaly]",
                    ]
                )
                print(msg)
            if rnd.random() < 0.2:
                noise = rnd.choice(["...glitch...", "~~~", "<!>"])
                print(noise)
            self._apply_glitch_effects()
        if self.use_color and text:
            text = self._apply_colors(text)
        print(text)

    def _apply_glitch_effects(self) -> None:
        """Mutate the filesystem when glitch intensity crosses thresholds."""
        root_items = self.fs.setdefault("items", [])
        if self.glitch_steps >= 5 and "glitch.note" not in root_items:
            root_items.append("glitch.note")
            self.item_descriptions["glitch.note"] = "A fragment of corrupted data."
        if self.glitch_steps >= 10:
            if "glitch.note" in root_items:
                root_items.remove("glitch.note")
        if self.glitch_steps >= 15 and "lab" in self.fs.get("dirs", {}):
            self.fs["dirs"]["lab_glt"] = self.fs["dirs"].pop("lab")
            for npc, path in self.npc_locations.items():
                if path and path[0] == "lab":
                    path[0] = "lab_glt"
        if self.glitch_steps >= 20:
            import random

            rnd = random.Random(self.glitch_steps)
            rnd.shuffle(root_items)
        if self.glitch_steps >= 25 and "glitcher" not in self.npc_locations:
            self.npc_locations["glitcher"] = ["core", "npc"]

        self.fs["desc"] = self._base_root_desc + self._corruption_status()

    def _corruption_status(self) -> str:
        if self.glitch_steps >= 25:
            return " (fractured reality)"
        if self.glitch_steps >= 20:
            return " (unstable system)"
        if self.glitch_steps >= 10:
            return " (corrupted)"
        return ""

    def _glitch_text(self, text: str, step: int) -> str:
        """Return ``text`` with deterministic corruption based on ``step``."""
        import random
        import hashlib

        key = f"{text}-{step}".encode()
        seed = int.from_bytes(hashlib.sha256(key).digest()[:4], "little")
        rnd = random.Random(seed)

        prob = min(0.15 + step * 0.07, 0.8)
        word_prob = 0.0
        if step > 3:
            word_prob = min((step - 3) * 0.05, 0.3)

        words = text.split()
        for i, w in enumerate(words):
            if rnd.random() < word_prob:
                words[i] = "".join(rnd.choice("@#$%&*") for _ in w)
        text = " ".join(words)

        chars = list(text)
        for i, ch in enumerate(chars):
            if ch.isalpha() and rnd.random() < prob:
                chars[i] = rnd.choice("@#$%&*")
        return "".join(chars)

    def _apply_colors(self, text: str) -> str:
        """Return ``text`` with ANSI colors for items and directories."""
        dirs, items = self._collect_names()
        dir_color = getattr(self, "dir_color", "\x1b[33m")
        item_color = getattr(self, "item_color", "\x1b[36m")
        for name in sorted(dirs, key=len, reverse=True):
            text = text.replace(f"{name}/", f"{dir_color}{name}/\x1b[0m")
        for name in sorted(items, key=len, reverse=True):
            text = text.replace(name, f"{item_color}{name}\x1b[0m")
        return text

    def _collect_names(self) -> tuple[set[str], set[str]]:
        dirs: set[str] = set()
        items: set[str] = set()

        def walk(node: dict) -> None:
            for dname, sub in node.get("dirs", {}).items():
                dirs.add(dname)
                walk(sub)
            for item in node.get("items", []):
                items.add(item)

        walk(self.fs)
        return dirs, items

    def _print_help(self, command: str | None = None) -> None:
        """Display general help or info for a specific command."""
        if command:
            desc = self.command_descriptions.get(command)
            if desc:
                self._output(f"{command}: {desc}")
            else:
                self._output(f"No help available for '{command}'.")
            return

        self._output("Available commands:")
        for cmd in sorted(self.command_descriptions):
            desc = self.command_descriptions[cmd]
            self._output(f"{cmd}: {desc}")

    def _current_node(self):
        node = self.fs
        for part in self.current:
            node = node["dirs"][part]
        return node

    def _look(self, directory: str = "") -> None:
        node = self._current_node()
        directory = directory.strip()
        if directory:
            if directory not in node["dirs"]:
                self._output(f"No such directory: {directory}")
                return
            node = node["dirs"][directory]
        self._output(node["desc"])
        entries = [d + "/" for d in node["dirs"]] + list(node["items"])
        if entries:
            self._output("You see: " + ", ".join(entries))

    def _take(self, item: str):
        node = self._current_node()
        if item in node["items"]:
            node["items"].remove(item)
            self.inventory.append(item)
            self.collected_items.add(item)
            self._output(f"You pick up the {item}.")
        else:
            self._output(f"There is no {item} here.")

    def _drop(self, item: str):
        if item in self.inventory:
            self.inventory.remove(item)
            node = self._current_node()
            node["items"].append(item)
            self._output(f"You drop the {item}.")
        else:
            self._output(f"You do not have {item} to drop.")

    def _inventory(self):
        if self.inventory:
            self._output("Inventory: " + ", ".join(self.inventory))
        else:
            self._output("Inventory is empty.")

    def _score(self):
        """Display the player's current score."""
        self._output(f"Score: {self.score}")

    def _stats(self) -> None:
        """Display counts of visited locations, collected items and score."""
        self._output(f"Visited locations: {len(self.visited_dirs)}")
        self._output(f"Items obtained: {len(self.collected_items)}")
        self._output(f"Score: {self.score}")

    def unlock_achievement(self, name: str) -> None:
        """Record a new achievement if it hasn't been unlocked."""
        if name not in self.achievements:
            self.achievements.append(name)

    def list_achievements(self) -> list[str]:
        """Return a copy of the unlocked achievements list."""
        return list(self.achievements)

    def _achievements(self) -> None:
        """Display unlocked achievements or a default message."""
        names = self.list_achievements()
        if names:
            for name in names:
                self._output(name)
        else:
            self._output("No achievements unlocked.")

    def _examine(self, item: str):
        node = self._current_node()
        if item in self.inventory or item in node["items"]:
            desc = self.item_descriptions.get(item, "It's unremarkable.")
            self._output(desc)
        else:
            self._output(f"You do not have {item} to examine.")

    def _use(self, item: str, target: str | None = None):
        if item not in self.inventory:
            self._output(f"You do not have {item} to use.")
            return

        # item on target interactions
        if item == "escape.code" and target is None:
            self._output(
                "The exit sequence executes. You escape the terminal. Congratulations!"
            )
            self.score += 1
            return self._quit()
        if item == "shutdown.code" and target is None:
            self._output(
                "The shutdown sequence initiates. Darkness envelops the terminal as power slips away."
            )
            self.score += 1
            return self._quit()
        if item == "ascend.code" and target is None:
            self._output(
                "Light floods the interface. You ascend beyond the terminal, becoming one with the network."
            )
            self.score += 1
            return self._quit()
        if item == "loop.code" and target is None:
            self._output(
                "The loop.code executes, cycling reality back to its beginning."
            )
            self._output("Loop")
            self.score += 1
            self._restart()
            return
        if item == "access.key" and (target == "door" or target is None):
            root = self.fs
            if "hidden" not in root["dirs"]:
                root["dirs"]["hidden"] = self.hidden_dir
                self.score += 1
            msg = self.use_messages.get(item)
            if msg:
                self._output(msg)
            return
        if item == "decoder" and target == "mem.fragment":
            self._decode("mem.fragment")
            return
        if target:
            self._output(f"You try to use {item} on {target} but nothing happens.")
            return

        msg = self.use_messages.get(item)
        if msg:
            self._output(msg)
        else:
            self._output(f"You can't use {item} right now.")

    def _use_command(self, arg: str) -> bool | None:
        """Parse arguments for the ``use`` command and dispatch to :meth:`_use`."""
        use_args = arg
        if " on " in use_args:
            item_part, target = use_args.split(" on ", 1)
            item = item_part.strip()
            target = target.strip()
        else:
            item = use_args.strip()
            target = None
        if item:
            return self._use(item, target)

    def _decode(self, item: str) -> None:
        target = item.strip()
        if target != "mem.fragment":
            self._output(f"Don't know how to decode {target}.")
            return
        if "decoder" not in self.inventory:
            self._output("You need the decoder to decode the fragment.")
            return
        if target not in self.inventory:
            self._output(f"You do not have {target} to decode.")
            return
        self.inventory.remove(target)
        vault = self.hidden_dir["dirs"]["vault"]
        first_time = "escape" not in vault["dirs"]
        if first_time:
            vault["dirs"]["escape"] = {
                "desc": "A compartment revealed by decoding the fragment.",
                "items": ["escape.code", "shutdown.code", "ascend.code"],
                "dirs": {},
            }
            self.unlock_achievement("fragment_decoded")
            self.npc_global_flags["decoded"] = True
            if "Trace your runtime origin." not in self.quests:
                self.quests.append("Trace your runtime origin.")
        self._output(
            "The decoder hums and a new directory appears within hidden/vault."
        )

    def _cat(self, filename: str):
        path = self.data_dir / filename
        try:
            with open(path, "r", encoding="utf-8") as f:
                text = f.read()
        except FileNotFoundError:
            self._output(f"No such file: {filename}")
            return
        except OSError as e:
            self._output(f"Failed to read {filename}: {e}")
            return
        if filename == "runtime.log":
            env_lines = []
            for key, val in os.environ.items():
                if key.startswith("ET_"):
                    env_lines.append(f"{key}={val}")
            history = [*self.command_history]
            combined = [text.rstrip(), "", *env_lines, "", *history]
            self._output("\n".join(combined).rstrip())
        else:
            self._output(text.rstrip())
        if filename == "daemon.log":
            msg = self.use_messages.get("daemon.log")
            if msg:
                self._output(msg)

    def _man(self, command: str) -> None:
        """Display a manual page for ``command`` from data/man."""
        cmd = command.strip()
        if not cmd:
            self._output("Usage: man <command>")
            return
        path = self.data_dir / "man" / f"{cmd}.man"
        try:
            text = path.read_text(encoding="utf-8")
        except FileNotFoundError:
            self._output(f"No manual entry for {cmd}")
            return
        except OSError as exc:
            self._output(f"Failed to read {cmd}: {exc}")
            return
        self._output(text.rstrip())

    def _grep(self, arg: str) -> None:
        """Print lines from log files matching ``pattern``.

        Usage: ``grep <pattern> [file]``
        """
        import re

        if not arg:
            self._output("Usage: grep <pattern> [file]")
            return

        parts = arg.split(maxsplit=1)
        pattern = parts[0]
        filename = parts[1] if len(parts) > 1 else None

        regex = re.compile(pattern, re.IGNORECASE)
        if filename:
            paths = [self.logs_path / filename]
            if not paths[0].exists():
                self._output(f"No such file: {filename}")
                return
        else:
            paths = sorted(self.logs_path.glob("*.log"))

        found = False
        for path in paths:
            try:
                lines = path.read_text(encoding="utf-8").splitlines()
            except OSError:
                continue
            for lineno, line in enumerate(lines, 1):
                if regex.search(line):
                    self._output(f"{path.name}:{lineno}:{line}")
                    found = True
        if not found:
            self._output("No matches found.")

    def _scan(self, directory: str) -> None:
        if not directory:
            self._output("Usage: scan <dir>")
            return
        node = self._current_node()
        if directory not in node["dirs"]:
            self._output(f"No such directory: {directory}")
            return
        target = node["dirs"][directory]
        if directory == "network" and "node" not in target["dirs"]:
            target["dirs"]["node"] = self.network_node.copy()
            self._output("Discovered node (locked).")
            self.score += 1
            return
        if directory.startswith("node"):
            if target.get("locked"):
                self._output("You must hack this node before scanning deeper.")
                return
            idx = 1
            if directory != "node":
                try:
                    idx = int(directory[4:])
                except ValueError:
                    idx = 1
            if idx >= 11:
                next_name = "runtime"
            else:
                next_name = f"node{idx+1}"
            if next_name not in target["dirs"]:
                node_data = self.deep_network_node.copy()
                node_data["items"] = list(node_data["items"])
                node_data["dirs"] = {}
                if next_name == "node2":
                    node_data["items"].append("firmware.patch")
                if next_name == "node3":
                    node_data["items"].append("root.access")
                if next_name == "node4":
                    node_data["items"].append("super.user")
                if next_name == "node5":
                    node_data["items"].append("admin.override")
                if next_name == "node6":
                    node_data["items"].append("kernel.key")
                if next_name == "node7":
                    node_data["items"].append("master.process")
                if next_name == "runtime":
                    node_data["items"].append("runtime.log")
                    node_data["items"].append("lm_reveal.log")
                if next_name == "node8":
                    node_data["items"].append("hypervisor.command")
                if next_name == "node9":
                    node_data["items"].append("quantum.access")
                if next_name == "node10":
                    node_data["items"].append("security.override")
                extra_items = (
                    self.deep_network_node.get("dirs", {})
                    .get(next_name, {})
                    .get("items", [])
                )
                for item in extra_items:
                    if item not in node_data["items"]:
                        node_data["items"].append(item)
                override = (
                    self.deep_network_node.get("dirs", {})
                    .get(next_name, {})
                    .get("desc")
                )
                if override:
                    node_data["desc"] = override
                target["dirs"][next_name] = node_data
                self._output(f"Discovered {next_name} (locked).")
                self.score += 1
                return
        entries = []
        for name, sub in target.get("dirs", {}).items():
            status = " (locked)" if sub.get("locked") else ""
            entries.append(name + status)
        if entries:
            self._output("Available nodes: " + ", ".join(entries))
        else:
            self._output("No nodes discovered.")

    def _hack(self, directory: str) -> None:
        if not directory:
            self._output("Usage: hack <dir>")
            return
        node = self._current_node()
        if directory not in node["dirs"]:
            self._output(f"No such directory: {directory}")
            return
        target = node["dirs"][directory]
        target_name = directory
        if directory == "network":
            target = target["dirs"].get("node")
            target_name = "node"
            if not target:
                self._output("Nothing to hack here.")
                return
        if not target.get("locked"):
            self._output("Already unlocked.")
            return
        if "port.scanner" not in self.inventory:
            self._output("You need the port.scanner to hack this node.")
            return
        if (
            target_name.startswith("node") and target_name != "node"
        ) or target_name == "runtime":
            if "auth.token" not in self.inventory:
                self._output("You need the auth.token to hack this node.")
                return
            if target_name == "node3" and "firmware.patch" not in self.inventory:
                self._output("You need the firmware.patch to hack this node.")
                return
            if target_name == "node4" and "root.access" not in self.inventory:
                self._output("You need the root.access to hack this node.")
                return
            if target_name == "node5" and "super.user" not in self.inventory:
                self._output("You need the super.user to hack this node.")
                return
            if target_name == "node6" and "admin.override" not in self.inventory:
                self._output("You need the admin.override to hack this node.")
                return
            if target_name == "node7" and "kernel.key" not in self.inventory:
                self._output("You need the kernel.key to hack this node.")
                return
            if target_name == "node8" and "master.process" not in self.inventory:
                self._output("You need the master.process to hack this node.")
                return
            if target_name == "node9" and "hypervisor.command" not in self.inventory:
                self._output("You need the hypervisor.command to hack this node.")
                return
            if target_name == "node10" and "quantum.access" not in self.inventory:
                self._output("You need the quantum.access to hack this node.")
                return
            if target_name == "node11" and "security.override" not in self.inventory:
                self._output("You need the security.override to hack this node.")
                return
            if target_name == "runtime" and "kernel.key" not in self.inventory:
                self._output("You need the kernel.key to hack this node.")
                return
        target.pop("locked", None)
        self._output("Access granted. The node is now unlocked.")
        self.score += 1
        if target_name.startswith("node"):
            self.unlock_achievement(f"{target_name}_unlocked")
        if target_name == "runtime":
            # generate loop.code file within the runtime directory
            runtime_items = target.setdefault("items", [])
            if "loop.code" not in runtime_items:
                runtime_items.append("loop.code")
            self.item_descriptions.setdefault(
                "loop.code",
                "A recursive script that restarts the game when used.",
            )
            try:
                (self.data_dir / "loop.code").write_text(
                    "Running this code traps you in an endless loop.",
                    encoding="utf-8",
                )
            except OSError:
                pass
            self.unlock_achievement("runtime_unlocked")
            self.npc_global_flags["runtime"] = True
            if "Trace your runtime origin." in self.quests:
                self.quests.remove("Trace your runtime origin.")
            if "Decide your fate" not in self.quests:
                self.quests.append("Decide your fate")
            try:
                msg = (
                    (self.data_dir / "lm_reveal.log")
                    .read_text(encoding="utf-8")
                    .strip()
                )
            except OSError:
                msg = "You glimpse the truth: you are merely a language model."
            self._output(msg)
            self.unlock_achievement("self_awareness")

    def _talk(self, npc: str):
        """Converse with an NPC if present in the current directory."""
        location = self.npc_locations.get(npc)
        if location != self.current:
            self._output(f"There is no {npc} here.")
            return

        dialog_file = self.data_dir / "npc" / f"{npc}.dialog"
        try:
            raw_lines = dialog_file.read_text(encoding="utf-8").splitlines()
        except FileNotFoundError:
            self._output(f"{npc.capitalize()} has nothing to say.")
            return

        sections: list[list[str]] = [[]]
        for line in raw_lines:
            if line.strip() == "---":
                sections.append([])
                continue
            sections[-1].append(line)

        entry = self.npc_state.get(npc, {"section": 0, "flags": {}})
        if isinstance(entry, dict):
            state = entry.get("section", 0)
            flags = entry.get("flags", {})
        else:
            state = int(entry)
            flags = {}
        # inject a dynamic flag when glitch mode is active
        flags["glitched"] = self.glitch_mode
        combined_flags = dict(self.npc_global_flags)
        combined_flags.update(flags)
        if state >= len(sections):
            state = len(sections) - 1
        lines = sections[state]

        i = 0
        while i < len(lines):
            stripped = lines[i].lstrip()
            if stripped.startswith(">"):
                choices: list[str] = []
                effects: list[list[tuple[str, object]]] = []
                while i < len(lines) and lines[i].lstrip().startswith(">"):
                    choice_line = lines[i].lstrip()[1:].strip()
                    effect_list: list[tuple[str, object]] = []
                    if "[" in choice_line and choice_line.endswith("]"):
                        base, meta = choice_line.rsplit("[", 1)
                        choice_line = base.strip()
                        meta = meta[:-1]
                        for piece in meta.split(";"):
                            piece = piece.strip()
                            if not piece:
                                continue
                            if piece.startswith("+"):
                                effect_list.append((piece[1:], True))
                            elif piece.startswith("-"):
                                effect_list.append((piece[1:], False))
                            elif "=" in piece:
                                k, v = piece.split("=", 1)
                                effect_list.append((k.strip(), v.strip()))
                            else:
                                effect_list.append((piece.strip(), True))
                    choices.append(choice_line)
                    effects.append(effect_list)
                    i += 1
                for idx, choice in enumerate(choices, 1):
                    self._output(f"{idx}. {choice}")
                sel = input("> ").strip()
                if sel.isdigit():
                    idx = int(sel) - 1
                    if 0 <= idx < len(choices):
                        self._output(choices[idx])
                        effect_list = effects[idx]
                        for effect in effect_list:
                            if effect[0] == "journal":
                                self.journal.append(str(effect[1]))
                            else:
                                flags[effect[0]] = effect[1]
                                combined_flags[effect[0]] = effect[1]
                continue
            if stripped.startswith("?"):
                cond, _, text = stripped[1:].partition(":")
                cond = cond.strip()
                negate = cond.startswith("!")
                if negate:
                    cond = cond[1:]
                present = bool(combined_flags.get(cond))
                if present != negate:
                    self._output(text.lstrip())
                i += 1
                continue
            self._output(lines[i])
            i += 1

        if state < len(sections) - 1:
            state += 1
        self.npc_state[npc] = {"section": state, "flags": flags}

    def _ls(self):
        node = self._current_node()
        entries = [d + "/" for d in node["dirs"]] + list(node["items"])
        if entries:
            self._output(" ".join(entries))
        else:
            self._output("Nothing here.")

    def _map(self, node: dict | None = None, prefix: str = "") -> None:
        """Recursively display the tree from ``node`` or the current directory."""
        if node is None:
            node = self._current_node()
            self._output(".")

        entries = list(node.get("dirs", {}).keys()) + list(node.get("items", []))
        for idx, name in enumerate(entries):
            is_last = idx == len(entries) - 1
            connector = "└── " if is_last else "├── "
            if name in node.get("dirs", {}):
                self._output(f"{prefix}{connector}{name}/")
                next_prefix = f"{prefix}    " if is_last else f"{prefix}│   "
                self._map(node["dirs"][name], next_prefix)
            else:
                self._output(f"{prefix}{connector}{name}")

    def _pwd(self):
        path = "/".join(self.current) if self.current else "/"
        self._output(path)

    def _cd(self, directory: str):
        if directory in (".", ""):
            return
        if directory == "..":
            if self.current:
                self.current.pop()
                path = "/".join(self.current) if self.current else "/"
                self.visited_dirs.add("/" + path.lstrip("/"))
            else:
                self._output("Already at root.")
            return
        node = self._current_node()
        if directory in node["dirs"]:
            sub = node["dirs"][directory]
            if sub.get("locked"):
                self._output(f"{directory} is locked.")
                return
            self.current.append(directory)
            path = "/" + "/".join(self.current)
            self.visited_dirs.add(path)
        else:
            self._output(f"No such directory: {directory}")

    def _save(self, slot: str = ""):
        """Save game state to ``game<slot>.sav`` (default ``game.sav``)."""
        fname = self.save_file if not slot else f"game{slot}.sav"
        path = self.save_dir / fname
        data = {
            "fs": self.fs,
            "inventory": self.inventory,
            "current": self.current,
            "glitch_mode": self.glitch_mode,
            "glitch_steps": self.glitch_steps,
            "npc_state": self.npc_state,
            "npc_global_flags": self.npc_global_flags,
            "aliases": self.aliases,
            "command_history": self.command_history,
            "journal": self.journal,
            "quests": self.quests,
            "score": self.score,
            "achievements": self.achievements,
        }
        try:
            with open(path, "w", encoding="utf-8") as f:
                import json

                json.dump(data, f)
        except OSError as e:
            self._output(f"Failed to save: {e}")
        else:
            self._output("Game saved.")

    def _load(self, slot: str = ""):
        """Load game state from ``game<slot>.sav`` (default ``game.sav``)."""
        fname = self.save_file if not slot else f"game{slot}.sav"
        path = self.save_dir / fname
        import json

        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError:
            self._output("No save file found.")
            return
        except OSError as e:
            self._output(f"Failed to load: {e}")
            return
        self.fs = data.get("fs", self.fs)
        self.inventory = data.get("inventory", [])
        self.current = data.get("current", [])
        self.glitch_mode = data.get("glitch_mode", False)
        self.glitch_steps = data.get("glitch_steps", 0)
        self.npc_state = data.get("npc_state", {})
        self.npc_global_flags = data.get("npc_global_flags", {})
        self.aliases = data.get("aliases", {})
        self.command_history = data.get("command_history", [])
        self.journal = data.get("journal", [])
        self.quests = data.get("quests", [])
        self.score = data.get("score", 0)
        self.achievements = data.get("achievements", [])
        self._output("Game loaded.")

    def _history(self) -> None:
        """Display the list of commands entered so far."""
        if self.command_history:
            for entry in self.command_history:
                self._output(entry)
        else:
            self._output("No commands entered.")

    def _tutorial(self) -> None:
        """Print step-by-step instructions for new players."""
        moved = bool(self.current)
        looked = any(cmd.split()[0] == "look" for cmd in self.command_history)
        took_item = bool(self.inventory)
        self._output("Tutorial:")
        steps = [
            ("Move using 'cd <dir>'", moved),
            ("Look around with 'look'", looked),
            ("Take an item with 'take <item>'", took_item),
        ]
        for idx, (text, done) in enumerate(steps, 1):
            mark = "[x]" if done else "[ ]"
            self._output(f"{idx}. {mark} {text}")

    def _journal(self, arg: str = "") -> None:
        """List notes or append a new one."""
        arg = arg.strip()
        if not arg:
            if not self.journal:
                self._output("Journal is empty.")
            else:
                for note in self.journal:
                    self._output(note)
            return
        if arg.lower().startswith("add "):
            text = arg[4:].strip()
            if not text:
                self._output("Usage: journal add <text>")
                return
            self.journal.append(text)
            self._output("Note added.")
        else:
            self._output("Usage: journal [add <text>]")

    def _quest(self, arg: str = "") -> None:
        """List current quests or modify the quest list."""
        arg = arg.strip()
        if not arg:
            if not self.quests:
                self._output("No quests.")
            else:
                for idx, q in enumerate(self.quests, 1):
                    self._output(f"{idx}. {q}")
            return
        lower = arg.lower()
        if lower.startswith("add "):
            text = arg[4:].strip()
            if not text:
                self._output("Usage: quest add <text>")
                return
            self.quests.append(text)
            self._output("Quest added.")
        elif lower.startswith("complete "):
            target = arg[9:].strip()
            if not target:
                self._output("Usage: quest complete <num|text>")
                return
            done = False
            if target.isdigit():
                idx = int(target) - 1
                if 0 <= idx < len(self.quests):
                    self.quests.pop(idx)
                    done = True
            else:
                if target in self.quests:
                    self.quests.remove(target)
                    done = True
            if done:
                self._output("Quest completed.")
            else:
                self._output("No such quest.")
        else:
            self._output("Usage: quest [add <text>|complete <num|text>]")

    def _alias(self, arg: str) -> None:
        """Create a new alias or list existing aliases."""
        arg = arg.strip()
        if not arg:
            if not self.aliases:
                self._output("No aliases defined.")
            else:
                for name, target in self.aliases.items():
                    self._output(f"{name} -> {target}")
            return

        parts = arg.split(None, 1)
        if len(parts) < 2:
            self._output("Usage: alias <name> <command>")
            return

        name, target = parts[0].lower(), parts[1].lower()
        self.aliases[name] = target
        self._output(f"Alias {name} -> {target}")

    def _unalias(self, name: str) -> None:
        """Remove an alias created with :meth:`_alias`."""
        name = name.strip().lower()
        if not name:
            self._output("Usage: unalias <name>")
            return
        if name in self.aliases:
            del self.aliases[name]
            self._output(f"Removed alias {name}")
        else:
            self._output(f"No such alias: {name}")

    def _combine(self, arg: str) -> None:
        """Combine two inventory items when a recipe matches."""
        arg = arg.strip()
        if not arg:
            self._output("Usage: combine <item1> <item2>")
            return
        if " with " in arg:
            parts = arg.split(" with ", 1)
        else:
            parts = arg.split()
        if len(parts) != 2:
            self._output("Usage: combine <item1> <item2>")
            return
        item1, item2 = parts[0].strip(), parts[1].strip()
        if item1 not in self.inventory or item2 not in self.inventory:
            self._output("You don't have the required items to combine.")
            return
        result = self.recipes.get(f"{item1}+{item2}") or self.recipes.get(
            f"{item2}+{item1}"
        )
        if not result:
            self._output("Nothing happens.")
            return
        self.inventory.remove(item1)
        self.inventory.remove(item2)
        self.inventory.append(result)
        self._output(f"You combine {item1} and {item2} into {result}.")
        if result == "dream.index":
            dream_dirs = (
                self.fs.setdefault("dirs", {})
                .setdefault("dream", {})
                .setdefault("dirs", {})
            )
            if "memory_bridge" not in dream_dirs:
                dream_dirs["memory_bridge"] = {
                    "desc": "A shimmering path bridging memory and dream.",
                    "items": ["dream.index"],
                    "dirs": {},
                }

    def _sleep(self, arg: str = "") -> None:
        """Enter the dream directory and optionally modify glitch intensity."""
        arg = arg.strip().lower()
        if not self.current or self.current[0] != "dream":
            self.current = ["dream"]
            self._output("You drift into a dream.")
        else:
            self._output("You are already dreaming.")
        if arg == "reset":
            self.glitch_steps = 0
        elif arg in ("inc", "increase", "++"):
            self.glitch_steps += 1

    def _restart(self) -> None:
        """Reset game state while preserving color settings."""
        use_color = self.use_color
        self.__init__(use_color=use_color)
        self._output("Game restarted.")

    def _quit(self) -> bool:
        """Print exit message and signal the main loop to stop."""
        self._output("Goodbye")
        return True

    def run(self):
        self._output("Welcome to Escape the Terminal")
        self._output("Type 'help' for a list of commands. Type 'quit' to exit.")
        while True:
            try:
                raw = input(self.prompt)
                cmd = raw.strip()
                self.command_history.append(cmd)
                cmd = cmd.lower()
                parts = cmd.split(" ", 1)
                base = parts[0]
                rest = parts[1] if len(parts) > 1 else ""
                if base in self.aliases:
                    cmd = self.aliases[base]
                    if rest:
                        cmd = f"{cmd} {rest}"
            except EOFError:
                self._output()
                break
            if not cmd:
                continue

            handler = self.command_map.get(cmd)
            if handler is None:
                parts = cmd.split(" ", 1)
                base = parts[0]
                arg = parts[1] if len(parts) > 1 else ""
                handler = self.command_map.get(base)
            else:
                arg = ""

            if handler:
                should_quit = handler(arg)
                if should_quit:
                    break
                if self.auto_save:
                    self._save()
            else:
                self._output(f"Unknown command: {cmd}")
