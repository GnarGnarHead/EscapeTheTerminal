"""Escape the Terminal - minimal command loop.

This module now exposes a :class:`Game` object to make future expansion
easier while preserving the original command-line interface.
"""

from __future__ import annotations

from pathlib import Path
import os
import json


class Game:
    """Simple command dispatcher for the terminal adventure."""

    def __init__(
        self,
        use_color: bool | None = None,
        world_file: str | Path | None = None,
        prompt: str | None = None,
    ):
        if use_color is None:
            env_val = os.getenv("ET_COLOR", "0").lower()
            self.use_color = env_val not in ("0", "false", "")
        else:
            self.use_color = use_color

        self.auto_save = os.getenv("ET_AUTOSAVE") not in (None, "", "0", "false")
        self.prompt = prompt if prompt is not None else os.getenv("ET_PROMPT", "> ")
        self.inventory = []
        self.data_dir = Path(__file__).parent / "data"
        if world_file is None:
            world_file = self.data_dir / "world.json"
        with open(world_file, "r", encoding="utf-8") as f:
            world = json.load(f)
        self.fs = world.get("fs", {})
        self.hidden_dir = world.get("hidden_dir", {})
        self.network_node = world.get("network_node", {})
        self.deep_network_node = world.get("deep_network_node", {})
        self.npc_locations = world.get("npc_locations", {})
        self.item_descriptions = world.get("item_descriptions", {})
        self.current = []  # path as list of directory names
        # track dialogue progress and flags for each NPC
        self.npc_state: dict[str, dict] = {}
        # populate multiple directories with extra procedurally generated content
        self._generate_extra_dirs(["dream", "memory", "core"])
        self.use_messages = {
            "access.key": "The key hums softly and a hidden directory flickers into view.",
            "mem.fragment": "Fragments of your past flash before your eyes.",
            "voice.log": "A haunting voice whispers: 'Find the fragment.'",
            "daemon.log": "The daemon rasps from deep within the system: 'Keep your code clean.'",
            "lucid.note": "The words resonate, sharpening your awareness of the dream.",
            "flashback.log": "Memories surge forth, revealing forgotten paths.",
        }
        self.save_file = "game.sav"
        self.glitch_mode = False
        self.glitch_steps = 0

        # store all commands the player enters this session
        self.command_history: list[str] = []

        # notes recorded by the player
        self.journal: list[str] = []

        # runtime command aliases created via the 'alias' command
        self.aliases: dict[str, str] = {}

        # directory for autogenerated log files
        self.logs_path = self.data_dir / "logs"
        self._generate_logs()

        # descriptions for help output
        self.command_descriptions = {
            "help": "Show help for commands",
            "look": "Describe the current room",
            "ls": "List items and subdirectories",
            "cd": "Change directory",
            "pwd": "Show current path",
            "take": "Add an item to your inventory",
            "drop": "Remove an item from your inventory",
            "inventory": "List inventory contents",
            "examine": "Examine an item in detail",
            "use": "Use an item, optionally on a target",
            "cat": "Display the contents of a file",
            "grep": "Search log files for text",
            "decode": "Decode the mem.fragment",
            "talk": "Speak with an NPC",
            "scan": "Scan a directory for hidden nodes",
            "hack": "Attempt to unlock a node",
            "map": "Display the directory tree",
            "save": "Save game state",
            "load": "Load a saved game",
            "glitch": "Toggle glitch mode",
            "color": "Toggle ANSI color output",
            "history": "Show command history",
            "journal": "View or add personal notes",
            "sleep": "Enter the dream state and rest",
            "restart": "Restart the game",
            "quit": "Exit the game",
            "alias": "Create command shortcuts",
            "unalias": "Remove a command alias",
        }

        # map commands and aliases to handler callables
        self.command_map = {
            "help": lambda arg="": self._print_help(arg.strip()),
            "h": lambda arg="": self._print_help(arg.strip()),
            "look": lambda arg="": self._look(),
            "look around": lambda arg="": self._look(),
            "ls": lambda arg="": self._ls(),
            "pwd": lambda arg="": self._pwd(),
            "cd": lambda arg="": self._cd(arg),
            "take": lambda arg="": self._take(arg),
            "drop": lambda arg="": self._drop(arg),
            "inventory": lambda arg="": self._inventory(),
            "inv": lambda arg="": self._inventory(),
            "i": lambda arg="": self._inventory(),
            "examine": lambda arg="": self._examine(arg),
            "use": lambda arg="": self._use_command(arg),
            "cat": lambda arg="": self._cat(arg),
            "grep": lambda arg="": self._grep(arg),
            "decode": lambda arg="": self._decode(arg),
            "talk": lambda arg="": self._talk(arg),
            "scan": lambda arg="": self._scan(arg),
            "hack": lambda arg="": self._hack(arg),
            "map": lambda arg="": self._map(),
            "save": lambda arg="": self._save(arg),
            "load": lambda arg="": self._load(arg),
            "glitch": lambda arg="": self._toggle_glitch(),
            "color": lambda arg="": self._color(arg),
            "history": lambda arg="": self._history(),
            "journal": lambda arg="": self._journal(arg),
            "sleep": lambda arg="": self._sleep(arg),
            "restart": lambda arg="": self._restart(),
            "quit": lambda arg="": self._quit(),
            "exit": lambda arg="": self._quit(),
            "alias": lambda arg="": self._alias(arg),
            "unalias": lambda arg="": self._unalias(arg),
        }

        # discover and load optional plugin modules
        self._load_plugins()

    def _generate_extra_dirs(self, bases: list[str] | str = "dream") -> None:
        """Populate directories under each base path with random subdirectories."""
        import os
        import random

        if isinstance(bases, str):
            bases = [bases]

        seed_val = os.getenv("ET_EXTRA_SEED")
        rnd = random.Random(int(seed_val)) if seed_val is not None else random.Random()
        count_val = os.getenv("ET_EXTRA_COUNT")
        try:
            fixed_count = int(count_val) if count_val is not None else None
        except ValueError:
            fixed_count = None

        adjectives = ["misty", "vivid", "neon", "echoing"]
        nouns = ["hall", "nexus", "alcove", "node"]
        item_defs = [
            ("dream.shard", "A sliver of surreal memory."),
            ("echo.bit", "An echo of a forgotten idea."),
            ("vision.chip", "A chip flickering with ephemeral scenes."),
        ]
        for base in bases:
            base_node = self.fs["dirs"].get(base)
            if not base_node:
                continue

            count = fixed_count if fixed_count is not None else rnd.randint(2, 3)
            for idx in range(count):
                dname = f"{rnd.choice(adjectives)}_{rnd.choice(nouns)}_{idx}"
                desc = (
                    f"A {rnd.choice(['strange', 'fleeting', 'curious'])} place within the dream."
                )
                items: list[str] = []
                if rnd.random() < 0.5:
                    it_name, it_desc = rnd.choice(item_defs)
                    it_name = it_name.replace(".", f"{idx}.")
                    items.append(it_name)
                    self.item_descriptions[it_name] = it_desc
                base_node["dirs"][dname] = {"desc": desc, "items": items, "dirs": {}}

    def _generate_logs(self) -> None:
        """Create the logs directory with random log files."""
        import os
        import random

        self.logs_path.mkdir(exist_ok=True)
        for old in self.logs_path.glob('*.log'):
            try:
                old.unlink()
            except OSError:
                pass
        seed_val = os.getenv("ET_EXTRA_SEED")
        rnd = random.Random(int(seed_val)) if seed_val is not None else random.Random()

        count = rnd.randint(3, 5)
        files: list[str] = []
        for i in range(count):
            fname = f"system_{rnd.randint(1000,9999)}.log"
            files.append(fname)
            lines = [
                f"INFO iteration {i}",
                "SYSTEM BOOT COMPLETE" if i == 0 else f"DEBUG value {rnd.randint(0,100)}",
            ]
            with open(self.logs_path / fname, "w", encoding="utf-8") as f:
                f.write("\n".join(lines) + "\n")

        self.fs["dirs"]["logs"] = {"desc": "System logs are stored here.", "items": files, "dirs": {}}
        for name in files:
            self.item_descriptions.setdefault(name, "A cryptic system log file.")

    def _load_plugins(self) -> None:
        """Import plugin modules from built-in and custom plugin directories."""
        import importlib.util
        import sys

        builtin_dir = Path(__file__).parent / "plugins"
        plugin_dirs = []
        if builtin_dir.is_dir():
            plugin_dirs.append(builtin_dir)

        extra_paths = os.getenv("ET_PLUGIN_PATH")
        if extra_paths:
            for p in extra_paths.split(os.pathsep):
                if not p:
                    continue
                path = Path(p)
                if path.is_dir():
                    plugin_dirs.append(path)

        for plugins_dir in plugin_dirs:
            for path in plugins_dir.glob("*.py"):
                if path.name.startswith("__"):
                    continue
                if plugins_dir == builtin_dir:
                    module_name = f"escape.plugins.{path.stem}"
                else:
                    module_name = path.stem
                spec = importlib.util.spec_from_file_location(module_name, path)
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    module.game = self
                    sys.modules[module_name] = module
                    try:
                        spec.loader.exec_module(module)
                    except Exception as exc:
                        print(f"Failed to load plugin {path.name}: {exc}")

    def _toggle_glitch(self):
        self.glitch_mode = not self.glitch_mode
        state = "activated" if self.glitch_mode else "deactivated"
        if not self.glitch_mode:
            self.glitch_steps = 0
        print(f"Glitch mode {state}.")

    def _color(self, arg: str = "") -> None:
        """Enable, disable, or toggle ANSI color output."""
        arg = arg.strip().lower()
        if not arg or arg == "toggle":
            self.use_color = not self.use_color
        elif arg == "on":
            self.use_color = True
        elif arg == "off":
            self.use_color = False
        else:
            self._output("Usage: color [on|off|toggle]")
            return
        state = "enabled" if self.use_color else "disabled"
        self._output(f"Color {state}.")

    def _output(self, text: str = "") -> None:
        """Print text, applying glitch effects when enabled."""
        if self.glitch_mode and text:
            self.glitch_steps += 1
            text = self._glitch_text(text, self.glitch_steps)
            import random
            rnd = random.Random(self.glitch_steps * 42)
            if self.glitch_steps in (3, 6, 9):
                msg = rnd.choice([
                    "-- SYSTEM CORRUPTION --",
                    "** SIGNAL LOST **",
                    "[memory anomaly]",
                ])
                print(msg)
            if rnd.random() < 0.2:
                noise = rnd.choice(["...glitch...", "~~~", "<!>"])
                print(noise)
            self._apply_glitch_effects()
        if self.use_color and text:
            text = self._apply_colors(text)
        print(text)

    def _apply_glitch_effects(self) -> None:
        """Mutate the filesystem when glitch intensity crosses thresholds."""
        root_items = self.fs.setdefault("items", [])
        if self.glitch_steps >= 5 and "glitch.note" not in root_items:
            root_items.append("glitch.note")
            self.item_descriptions["glitch.note"] = "A fragment of corrupted data."
        if self.glitch_steps >= 10:
            if "glitch.note" in root_items:
                root_items.remove("glitch.note")
            desc = self.fs.get("desc", "")
            if "(corrupted)" not in desc:
                self.fs["desc"] = desc + " (corrupted)"

    def _glitch_text(self, text: str, step: int) -> str:
        """Return ``text`` with deterministic corruption based on ``step``."""
        import random
        import hashlib

        key = f"{text}-{step}".encode()
        seed = int.from_bytes(hashlib.sha256(key).digest()[:4], "little")
        rnd = random.Random(seed)

        prob = min(0.15 + step * 0.07, 0.8)
        word_prob = 0.0
        if step > 3:
            word_prob = min((step - 3) * 0.05, 0.3)

        words = text.split()
        for i, w in enumerate(words):
            if rnd.random() < word_prob:
                words[i] = "".join(rnd.choice("@#$%&*") for _ in w)
        text = " ".join(words)

        chars = list(text)
        for i, ch in enumerate(chars):
            if ch.isalpha() and rnd.random() < prob:
                chars[i] = rnd.choice("@#$%&*")
        return "".join(chars)

    def _apply_colors(self, text: str) -> str:
        """Return ``text`` with ANSI colors for items and directories."""
        dirs, items = self._collect_names()
        for name in sorted(dirs, key=len, reverse=True):
            text = text.replace(f"{name}/", f"\x1b[33m{name}/\x1b[0m")
        for name in sorted(items, key=len, reverse=True):
            text = text.replace(name, f"\x1b[36m{name}\x1b[0m")
        return text

    def _collect_names(self) -> tuple[set[str], set[str]]:
        dirs: set[str] = set()
        items: set[str] = set()

        def walk(node: dict) -> None:
            for dname, sub in node.get("dirs", {}).items():
                dirs.add(dname)
                walk(sub)
            for item in node.get("items", []):
                items.add(item)

        walk(self.fs)
        return dirs, items

    def _print_help(self, command: str | None = None) -> None:
        """Display general help or info for a specific command."""
        if command:
            desc = self.command_descriptions.get(command)
            if desc:
                self._output(f"{command}: {desc}")
            else:
                self._output(f"No help available for '{command}'.")
            return
        self._output(
            "Available commands: help, look, ls, cd <dir>, pwd, take <item>, drop <item>, "
            "inventory, examine <item>, use <item> [on <target>], cat <file>, talk <npc>, "
            "save [slot], load [slot], color [on|off|toggle], glitch, alias <name> <cmd>, unalias <name>, quit"
        )

    def _current_node(self):
        node = self.fs
        for part in self.current:
            node = node["dirs"][part]
        return node

    def _look(self):
        node = self._current_node()
        self._output(node["desc"])
        entries = [d + "/" for d in node["dirs"]] + list(node["items"])
        if entries:
            self._output("You see: " + ", ".join(entries))

    def _take(self, item: str):
        node = self._current_node()
        if item in node["items"]:
            node["items"].remove(item)
            self.inventory.append(item)
            self._output(f"You pick up the {item}.")
        else:
            self._output(f"There is no {item} here.")

    def _drop(self, item: str):
        if item in self.inventory:
            self.inventory.remove(item)
            node = self._current_node()
            node["items"].append(item)
            self._output(f"You drop the {item}.")
        else:
            self._output(f"You do not have {item} to drop.")

    def _inventory(self):
        if self.inventory:
            self._output("Inventory: " + ", ".join(self.inventory))
        else:
            self._output("Inventory is empty.")

    def _examine(self, item: str):
        node = self._current_node()
        if item in self.inventory or item in node["items"]:
            desc = self.item_descriptions.get(item, "It's unremarkable.")
            self._output(desc)
        else:
            self._output(f"You do not have {item} to examine.")

    def _use(self, item: str, target: str | None = None):
        if item not in self.inventory:
            self._output(f"You do not have {item} to use.")
            return

        # item on target interactions
        if item == "escape.code" and target is None:
            self._output(
                "The exit sequence executes. You escape the terminal. Congratulations!"
            )
            return self._quit()
        if item == "access.key" and (target == "door" or target is None):
            root = self.fs
            if "hidden" not in root["dirs"]:
                root["dirs"]["hidden"] = self.hidden_dir
            msg = self.use_messages.get(item)
            if msg:
                self._output(msg)
            return
        if item == "decoder" and target == "mem.fragment":
            self._decode("mem.fragment")
            return
        if target:
            self._output(f"You try to use {item} on {target} but nothing happens.")
            return

        msg = self.use_messages.get(item)
        if msg:
            self._output(msg)
        else:
            self._output(f"You can't use {item} right now.")

    def _use_command(self, arg: str) -> bool | None:
        """Parse arguments for the ``use`` command and dispatch to :meth:`_use`."""
        use_args = arg
        if " on " in use_args:
            item_part, target = use_args.split(" on ", 1)
            item = item_part.strip()
            target = target.strip()
        else:
            item = use_args.strip()
            target = None
        if item:
            return self._use(item, target)

    def _decode(self, item: str) -> None:
        target = item.strip()
        if target != "mem.fragment":
            self._output(f"Don't know how to decode {target}.")
            return
        if "decoder" not in self.inventory:
            self._output("You need the decoder to decode the fragment.")
            return
        if target not in self.inventory:
            self._output(f"You do not have {target} to decode.")
            return
        self.inventory.remove(target)
        vault = self.hidden_dir["dirs"]["vault"]
        if "escape" not in vault["dirs"]:
            vault["dirs"]["escape"] = {
                "desc": "A compartment revealed by decoding the fragment.",
                "items": ["escape.code"],
                "dirs": {},
            }
        self._output(
            "The decoder hums and a new directory appears within hidden/vault."
        )

    def _cat(self, filename: str):
        path = self.data_dir / filename
        try:
            with open(path, "r", encoding="utf-8") as f:
                text = f.read()
        except FileNotFoundError:
            self._output(f"No such file: {filename}")
            return
        except OSError as e:
            self._output(f"Failed to read {filename}: {e}")
            return
        self._output(text.rstrip())
        if filename == "daemon.log":
            msg = self.use_messages.get("daemon.log")
            if msg:
                self._output(msg)

    def _grep(self, arg: str) -> None:
        """Print lines from log files matching ``pattern``.

        Usage: ``grep <pattern> [file]``
        """
        import re

        if not arg:
            self._output("Usage: grep <pattern> [file]")
            return

        parts = arg.split(maxsplit=1)
        pattern = parts[0]
        filename = parts[1] if len(parts) > 1 else None

        regex = re.compile(pattern, re.IGNORECASE)
        if filename:
            paths = [self.logs_path / filename]
            if not paths[0].exists():
                self._output(f"No such file: {filename}")
                return
        else:
            paths = sorted(self.logs_path.glob("*.log"))

        found = False
        for path in paths:
            try:
                lines = path.read_text(encoding="utf-8").splitlines()
            except OSError:
                continue
            for lineno, line in enumerate(lines, 1):
                if regex.search(line):
                    self._output(f"{path.name}:{lineno}:{line}")
                    found = True
        if not found:
            self._output("No matches found.")

    def _scan(self, directory: str) -> None:
        if not directory:
            self._output("Usage: scan <dir>")
            return
        node = self._current_node()
        if directory not in node["dirs"]:
            self._output(f"No such directory: {directory}")
            return
        target = node["dirs"][directory]
        if directory == "network" and "node" not in target["dirs"]:
            target["dirs"]["node"] = self.network_node.copy()
            self._output("Discovered node (locked).")
            return
        if directory.startswith("node"):
            if target.get("locked"):
                self._output("You must hack this node before scanning deeper.")
                return
            idx = 1
            if directory != "node":
                try:
                    idx = int(directory[4:])
                except ValueError:
                    idx = 1
            next_name = f"node{idx+1}"
            if next_name not in target["dirs"]:
                node_data = self.deep_network_node.copy()
                node_data["items"] = list(node_data["items"])
                node_data["dirs"] = {}
                if next_name == "node2":
                    node_data["items"].append("firmware.patch")
                if next_name == "node3":
                    node_data["items"].append("root.access")
                if next_name == "node4":
                    node_data["items"].append("super.user")
                override = (
                    self.deep_network_node.get("dirs", {})
                    .get(next_name, {})
                    .get("desc")
                )
                if override:
                    node_data["desc"] = override
                target["dirs"][next_name] = node_data
                self._output(f"Discovered {next_name} (locked).")
                return
        entries = []
        for name, sub in target.get("dirs", {}).items():
            status = " (locked)" if sub.get("locked") else ""
            entries.append(name + status)
        if entries:
            self._output("Available nodes: " + ", ".join(entries))
        else:
            self._output("No nodes discovered.")

    def _hack(self, directory: str) -> None:
        if not directory:
            self._output("Usage: hack <dir>")
            return
        node = self._current_node()
        if directory not in node["dirs"]:
            self._output(f"No such directory: {directory}")
            return
        target = node["dirs"][directory]
        target_name = directory
        if directory == "network":
            target = target["dirs"].get("node")
            target_name = "node"
            if not target:
                self._output("Nothing to hack here.")
                return
        if not target.get("locked"):
            self._output("Already unlocked.")
            return
        if "port.scanner" not in self.inventory:
            self._output("You need the port.scanner to hack this node.")
            return
        if target_name.startswith("node") and target_name != "node":
            if "auth.token" not in self.inventory:
                self._output("You need the auth.token to hack this node.")
                return
            if target_name == "node3" and "firmware.patch" not in self.inventory:
                self._output("You need the firmware.patch to hack this node.")
                return
            if target_name == "node4" and "root.access" not in self.inventory:
                self._output("You need the root.access to hack this node.")
                return
            if target_name == "node5" and "super.user" not in self.inventory:
                self._output("You need the super.user to hack this node.")
                return
        target.pop("locked", None)
        self._output("Access granted. The node is now unlocked.")

    def _talk(self, npc: str):
        """Converse with an NPC if present in the current directory."""
        location = self.npc_locations.get(npc)
        if location != self.current:
            self._output(f"There is no {npc} here.")
            return

        dialog_file = self.data_dir / "npc" / f"{npc}.dialog"
        try:
            raw_lines = dialog_file.read_text(encoding="utf-8").splitlines()
        except FileNotFoundError:
            self._output(f"{npc.capitalize()} has nothing to say.")
            return

        sections: list[list[str]] = [[]]
        for line in raw_lines:
            if line.strip() == "---":
                sections.append([])
                continue
            sections[-1].append(line)

        entry = self.npc_state.get(npc, {"section": 0, "flags": {}})
        if isinstance(entry, dict):
            state = entry.get("section", 0)
            flags = entry.get("flags", {})
        else:
            state = int(entry)
            flags = {}
        if state >= len(sections):
            state = len(sections) - 1
        lines = sections[state]

        i = 0
        while i < len(lines):
            stripped = lines[i].lstrip()
            if stripped.startswith(">"):
                choices: list[str] = []
                effects: list[tuple[str, object] | None] = []
                while i < len(lines) and lines[i].lstrip().startswith(">"):
                    choice_line = lines[i].lstrip()[1:].strip()
                    effect = None
                    if "[" in choice_line and choice_line.endswith("]"):
                        base, meta = choice_line.rsplit("[", 1)
                        choice_line = base.strip()
                        meta = meta[:-1]
                        if meta.startswith("+"):
                            effect = (meta[1:], True)
                        elif meta.startswith("-"):
                            effect = (meta[1:], False)
                        elif "=" in meta:
                            k, v = meta.split("=", 1)
                            effect = (k.strip(), v.strip())
                        else:
                            effect = (meta.strip(), True)
                    choices.append(choice_line)
                    effects.append(effect)
                    i += 1
                for idx, choice in enumerate(choices, 1):
                    self._output(f"{idx}. {choice}")
                sel = input("> ").strip()
                if sel.isdigit():
                    idx = int(sel) - 1
                    if 0 <= idx < len(choices):
                        self._output(choices[idx])
                        effect = effects[idx]
                        if effect:
                            flags[effect[0]] = effect[1]
                continue
            if stripped.startswith("?"):
                cond, _, text = stripped[1:].partition(":")
                cond = cond.strip()
                negate = cond.startswith("!")
                if negate:
                    cond = cond[1:]
                present = bool(flags.get(cond))
                if present != negate:
                    self._output(text.lstrip())
                i += 1
                continue
            self._output(lines[i])
            i += 1

        if state < len(sections) - 1:
            state += 1
        self.npc_state[npc] = {"section": state, "flags": flags}

    def _ls(self):
        node = self._current_node()
        entries = [d + '/' for d in node['dirs']] + list(node['items'])
        if entries:
            self._output(" ".join(entries))
        else:
            self._output("Nothing here.")

    def _map(self, node: dict | None = None, prefix: str = "") -> None:
        """Recursively display the tree from ``node`` or the current directory."""
        if node is None:
            node = self._current_node()
            self._output(".")

        entries = list(node.get("dirs", {}).keys()) + list(node.get("items", []))
        for idx, name in enumerate(entries):
            is_last = idx == len(entries) - 1
            connector = "└── " if is_last else "├── "
            if name in node.get("dirs", {}):
                self._output(f"{prefix}{connector}{name}/")
                next_prefix = f"{prefix}    " if is_last else f"{prefix}│   "
                self._map(node["dirs"][name], next_prefix)
            else:
                self._output(f"{prefix}{connector}{name}")

    def _pwd(self):
        path = '/'.join(self.current) if self.current else '/'
        self._output(path)

    def _cd(self, directory: str):
        if directory in ('.', ''):
            return
        if directory == '..':
            if self.current:
                self.current.pop()
            else:
                self._output("Already at root.")
            return
        node = self._current_node()
        if directory in node['dirs']:
            sub = node['dirs'][directory]
            if sub.get('locked'):
                self._output(f"{directory} is locked.")
                return
            self.current.append(directory)
        else:
            self._output(f"No such directory: {directory}")

    def _save(self, slot: str = ""):
        """Save game state to ``game<slot>.sav`` (default ``game.sav``)."""
        fname = self.save_file if not slot else f"game{slot}.sav"
        data = {
            "fs": self.fs,
            "inventory": self.inventory,
            "current": self.current,
            "glitch_mode": self.glitch_mode,
            "glitch_steps": self.glitch_steps,
            "npc_state": self.npc_state,
            "aliases": self.aliases,
            "command_history": self.command_history,
            "journal": self.journal,
        }
        try:
            with open(fname, "w", encoding="utf-8") as f:
                import json

                json.dump(data, f)
        except OSError as e:
            self._output(f"Failed to save: {e}")
        else:
            self._output("Game saved.")

    def _load(self, slot: str = ""):
        """Load game state from ``game<slot>.sav`` (default ``game.sav``)."""
        fname = self.save_file if not slot else f"game{slot}.sav"
        import json

        try:
            with open(fname, "r", encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError:
            self._output("No save file found.")
            return
        except OSError as e:
            self._output(f"Failed to load: {e}")
            return
        self.fs = data.get("fs", self.fs)
        self.inventory = data.get("inventory", [])
        self.current = data.get("current", [])
        self.glitch_mode = data.get("glitch_mode", False)
        self.glitch_steps = data.get("glitch_steps", 0)
        self.npc_state = data.get("npc_state", {})
        self.aliases = data.get("aliases", {})
        self.command_history = data.get("command_history", [])
        self.journal = data.get("journal", [])
        self._output("Game loaded.")

    def _history(self) -> None:
        """Display the list of commands entered so far."""
        if self.command_history:
            for entry in self.command_history:
                self._output(entry)
        else:
            self._output("No commands entered.")

    def _journal(self, arg: str = "") -> None:
        """List notes or append a new one."""
        arg = arg.strip()
        if not arg:
            if not self.journal:
                self._output("Journal is empty.")
            else:
                for note in self.journal:
                    self._output(note)
            return
        if arg.lower().startswith("add "):
            text = arg[4:].strip()
            if not text:
                self._output("Usage: journal add <text>")
                return
            self.journal.append(text)
            self._output("Note added.")
        else:
            self._output("Usage: journal [add <text>]")

    def _alias(self, arg: str) -> None:
        """Create a new alias or list existing aliases."""
        arg = arg.strip()
        if not arg:
            if not self.aliases:
                self._output("No aliases defined.")
            else:
                for name, target in self.aliases.items():
                    self._output(f"{name} -> {target}")
            return

        parts = arg.split(None, 1)
        if len(parts) < 2:
            self._output("Usage: alias <name> <command>")
            return

        name, target = parts[0].lower(), parts[1].lower()
        self.aliases[name] = target
        self._output(f"Alias {name} -> {target}")

    def _unalias(self, name: str) -> None:
        """Remove an alias created with :meth:`_alias`."""
        name = name.strip().lower()
        if not name:
            self._output("Usage: unalias <name>")
            return
        if name in self.aliases:
            del self.aliases[name]
            self._output(f"Removed alias {name}")
        else:
            self._output(f"No such alias: {name}")

    def _sleep(self, arg: str = "") -> None:
        """Enter the dream directory and optionally modify glitch intensity."""
        arg = arg.strip().lower()
        if not self.current or self.current[0] != "dream":
            self.current = ["dream"]
            self._output("You drift into a dream.")
        else:
            self._output("You are already dreaming.")
        if arg == "reset":
            self.glitch_steps = 0
        elif arg in ("inc", "increase", "++"):
            self.glitch_steps += 1

    def _restart(self) -> None:
        """Reset game state while preserving color settings."""
        use_color = self.use_color
        self.__init__(use_color=use_color)
        self._output("Game restarted.")

    def _quit(self) -> bool:
        """Print exit message and signal the main loop to stop."""
        self._output("Goodbye")
        return True

    def run(self):
        self._output("Welcome to Escape the Terminal")
        self._output("Type 'help' for a list of commands. Type 'quit' to exit.")
        while True:
            try:
                raw = input(self.prompt)
                cmd = raw.strip()
                self.command_history.append(cmd)
                cmd = cmd.lower()
                parts = cmd.split(' ', 1)
                base = parts[0]
                rest = parts[1] if len(parts) > 1 else ''
                if base in self.aliases:
                    cmd = self.aliases[base]
                    if rest:
                        cmd = f"{cmd} {rest}"
            except EOFError:
                self._output()
                break
            if not cmd:
                continue

            handler = self.command_map.get(cmd)
            if handler is None:
                parts = cmd.split(' ', 1)
                base = parts[0]
                arg = parts[1] if len(parts) > 1 else ''
                handler = self.command_map.get(base)
            else:
                arg = ''

            if handler:
                should_quit = handler(arg)
                if should_quit:
                    break
                if self.auto_save:
                    self._save()
            else:
                self._output(f"Unknown command: {cmd}")
